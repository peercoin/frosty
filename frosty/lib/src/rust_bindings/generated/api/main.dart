// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.28.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'main.freezed.dart';

FrostIdentifier identifierFromString({required String s, dynamic hint}) =>
    RustLib.instance.api.identifierFromString(s: s, hint: hint);

FrostIdentifier identifierFromU16({required int i, dynamic hint}) =>
    RustLib.instance.api.identifierFromU16(i: i, hint: hint);

FrostIdentifier identifierFromBytes({required List<int> bytes, dynamic hint}) =>
    RustLib.instance.api.identifierFromBytes(bytes: bytes, hint: hint);

Uint8List identifierToBytes(
        {required FrostIdentifier identifier, dynamic hint}) =>
    RustLib.instance.api.identifierToBytes(identifier: identifier, hint: hint);

(DkgRound1SecretPackage, DkgRound1Package) dkgPart1(
        {required FrostIdentifier identifier,
        required int maxSigners,
        required int minSigners,
        dynamic hint}) =>
    RustLib.instance.api.dkgPart1(
        identifier: identifier,
        maxSigners: maxSigners,
        minSigners: minSigners,
        hint: hint);

DkgRound1Package publicCommitmentFromBytes(
        {required List<int> bytes, dynamic hint}) =>
    RustLib.instance.api.publicCommitmentFromBytes(bytes: bytes, hint: hint);

Uint8List publicCommitmentToBytes(
        {required DkgRound1Package commitment, dynamic hint}) =>
    RustLib.instance.api
        .publicCommitmentToBytes(commitment: commitment, hint: hint);

(DkgRound2SecretPackage, List<DkgRound2IdentifierAndShare>) dkgPart2(
        {required DkgRound1SecretPackage round1Secret,
        required List<DkgCommitmentForIdentifier> round1Commitments,
        dynamic hint}) =>
    RustLib.instance.api.dkgPart2(
        round1Secret: round1Secret,
        round1Commitments: round1Commitments,
        hint: hint);

DkgRound2Package shareToGiveFromBytes(
        {required List<int> bytes, dynamic hint}) =>
    RustLib.instance.api.shareToGiveFromBytes(bytes: bytes, hint: hint);

Uint8List shareToGiveToBytes({required DkgRound2Package share, dynamic hint}) =>
    RustLib.instance.api.shareToGiveToBytes(share: share, hint: hint);

DkgRound3Data dkgPart3(
        {required DkgRound2SecretPackage round2Secret,
        required List<DkgCommitmentForIdentifier> round1Commitments,
        required List<DkgRound2IdentifierAndShare> round2Shares,
        dynamic hint}) =>
    RustLib.instance.api.dkgPart3(
        round2Secret: round2Secret,
        round1Commitments: round1Commitments,
        round2Shares: round2Shares,
        hint: hint);

(FrostRound1SigningNonces, FrostRound1SigningCommitments) signPart1(
        {required List<int> privateShare, dynamic hint}) =>
    RustLib.instance.api.signPart1(privateShare: privateShare, hint: hint);

FrostRound1SigningCommitments signingCommitmentFromBytes(
        {required List<int> bytes, dynamic hint}) =>
    RustLib.instance.api.signingCommitmentFromBytes(bytes: bytes, hint: hint);

Uint8List signingCommitmentToBytes(
        {required FrostRound1SigningCommitments commitment, dynamic hint}) =>
    RustLib.instance.api
        .signingCommitmentToBytes(commitment: commitment, hint: hint);

FrostRound2SignatureShare signPart2(
        {required List<IdentifierAndSigningCommitment> nonceCommitments,
        required List<int> message,
        Uint8List? merkleRoot,
        required FrostRound1SigningNonces signingNonce,
        required FrostIdentifier identifier,
        required List<int> privateShare,
        required List<int> groupPk,
        required int threshold,
        dynamic hint}) =>
    RustLib.instance.api.signPart2(
        nonceCommitments: nonceCommitments,
        message: message,
        merkleRoot: merkleRoot,
        signingNonce: signingNonce,
        identifier: identifier,
        privateShare: privateShare,
        groupPk: groupPk,
        threshold: threshold,
        hint: hint);

FrostRound2SignatureShare signatureShareFromBytes(
        {required List<int> bytes, dynamic hint}) =>
    RustLib.instance.api.signatureShareFromBytes(bytes: bytes, hint: hint);

Uint8List signatureShareToBytes(
        {required FrostRound2SignatureShare share, dynamic hint}) =>
    RustLib.instance.api.signatureShareToBytes(share: share, hint: hint);

Uint8List aggregateSignature(
        {required List<IdentifierAndSigningCommitment> nonceCommitments,
        required List<int> message,
        Uint8List? merkleRoot,
        required List<IdentifierAndSignatureShare> shares,
        required List<int> groupPk,
        required List<IdentifierAndPublicShare> publicShares,
        dynamic hint}) =>
    RustLib.instance.api.aggregateSignature(
        nonceCommitments: nonceCommitments,
        message: message,
        merkleRoot: merkleRoot,
        shares: shares,
        groupPk: groupPk,
        publicShares: publicShares,
        hint: hint);

// Rust type: RustOpaqueMoi<dkg :: round1 :: Package>
@sealed
class DkgRound1Package extends RustOpaque {
  DkgRound1Package.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  DkgRound1Package.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_DkgRound1Package,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_DkgRound1Package,
    rustArcDecrementStrongCountPtr: RustLib
        .instance.api.rust_arc_decrement_strong_count_DkgRound1PackagePtr,
  );
}

// Rust type: RustOpaqueMoi<dkg :: round1 :: SecretPackage>
@sealed
class DkgRound1SecretPackage extends RustOpaque {
  DkgRound1SecretPackage.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  DkgRound1SecretPackage.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib
        .instance.api.rust_arc_increment_strong_count_DkgRound1SecretPackage,
    rustArcDecrementStrongCount: RustLib
        .instance.api.rust_arc_decrement_strong_count_DkgRound1SecretPackage,
    rustArcDecrementStrongCountPtr: RustLib
        .instance.api.rust_arc_decrement_strong_count_DkgRound1SecretPackagePtr,
  );
}

// Rust type: RustOpaqueMoi<dkg :: round2 :: Package>
@sealed
class DkgRound2Package extends RustOpaque {
  DkgRound2Package.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  DkgRound2Package.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_DkgRound2Package,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_DkgRound2Package,
    rustArcDecrementStrongCountPtr: RustLib
        .instance.api.rust_arc_decrement_strong_count_DkgRound2PackagePtr,
  );
}

// Rust type: RustOpaqueMoi<dkg :: round2 :: SecretPackage>
@sealed
class DkgRound2SecretPackage extends RustOpaque {
  DkgRound2SecretPackage.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  DkgRound2SecretPackage.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib
        .instance.api.rust_arc_increment_strong_count_DkgRound2SecretPackage,
    rustArcDecrementStrongCount: RustLib
        .instance.api.rust_arc_decrement_strong_count_DkgRound2SecretPackage,
    rustArcDecrementStrongCountPtr: RustLib
        .instance.api.rust_arc_decrement_strong_count_DkgRound2SecretPackagePtr,
  );
}

// Rust type: RustOpaqueMoi<frost :: Identifier>
@sealed
class FrostIdentifier extends RustOpaque {
  FrostIdentifier.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  FrostIdentifier.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_FrostIdentifier,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_FrostIdentifier,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_FrostIdentifierPtr,
  );
}

// Rust type: RustOpaqueMoi<frost :: round1 :: SigningCommitments>
@sealed
class FrostRound1SigningCommitments extends RustOpaque {
  FrostRound1SigningCommitments.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  FrostRound1SigningCommitments.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib.instance.api
        .rust_arc_increment_strong_count_FrostRound1SigningCommitments,
    rustArcDecrementStrongCount: RustLib.instance.api
        .rust_arc_decrement_strong_count_FrostRound1SigningCommitments,
    rustArcDecrementStrongCountPtr: RustLib.instance.api
        .rust_arc_decrement_strong_count_FrostRound1SigningCommitmentsPtr,
  );
}

// Rust type: RustOpaqueMoi<frost :: round1 :: SigningNonces>
@sealed
class FrostRound1SigningNonces extends RustOpaque {
  FrostRound1SigningNonces.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  FrostRound1SigningNonces.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib
        .instance.api.rust_arc_increment_strong_count_FrostRound1SigningNonces,
    rustArcDecrementStrongCount: RustLib
        .instance.api.rust_arc_decrement_strong_count_FrostRound1SigningNonces,
    rustArcDecrementStrongCountPtr: RustLib.instance.api
        .rust_arc_decrement_strong_count_FrostRound1SigningNoncesPtr,
  );
}

// Rust type: RustOpaqueMoi<frost :: round2 :: SignatureShare>
@sealed
class FrostRound2SignatureShare extends RustOpaque {
  FrostRound2SignatureShare.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  FrostRound2SignatureShare.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib
        .instance.api.rust_arc_increment_strong_count_FrostRound2SignatureShare,
    rustArcDecrementStrongCount: RustLib
        .instance.api.rust_arc_decrement_strong_count_FrostRound2SignatureShare,
    rustArcDecrementStrongCountPtr: RustLib.instance.api
        .rust_arc_decrement_strong_count_FrostRound2SignatureSharePtr,
  );
}

class DkgCommitmentForIdentifier {
  final FrostIdentifier identifier;
  final DkgRound1Package commitment;

  const DkgCommitmentForIdentifier({
    required this.identifier,
    required this.commitment,
  });

  @override
  int get hashCode => identifier.hashCode ^ commitment.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DkgCommitmentForIdentifier &&
          runtimeType == other.runtimeType &&
          identifier == other.identifier &&
          commitment == other.commitment;
}

class DkgRound2IdentifierAndShare {
  final FrostIdentifier identifier;
  final DkgRound2Package secret;

  const DkgRound2IdentifierAndShare({
    required this.identifier,
    required this.secret,
  });

  @override
  int get hashCode => identifier.hashCode ^ secret.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DkgRound2IdentifierAndShare &&
          runtimeType == other.runtimeType &&
          identifier == other.identifier &&
          secret == other.secret;
}

class DkgRound3Data {
  final FrostIdentifier identifier;
  final Uint8List privateShare;
  final Uint8List groupPk;
  final List<IdentifierAndPublicShare> publicKeyShares;
  final int threshold;

  const DkgRound3Data({
    required this.identifier,
    required this.privateShare,
    required this.groupPk,
    required this.publicKeyShares,
    required this.threshold,
  });

  @override
  int get hashCode =>
      identifier.hashCode ^
      privateShare.hashCode ^
      groupPk.hashCode ^
      publicKeyShares.hashCode ^
      threshold.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DkgRound3Data &&
          runtimeType == other.runtimeType &&
          identifier == other.identifier &&
          privateShare == other.privateShare &&
          groupPk == other.groupPk &&
          publicKeyShares == other.publicKeyShares &&
          threshold == other.threshold;
}

class IdentifierAndPublicShare {
  final FrostIdentifier identifier;
  final Uint8List publicShare;

  const IdentifierAndPublicShare({
    required this.identifier,
    required this.publicShare,
  });

  @override
  int get hashCode => identifier.hashCode ^ publicShare.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is IdentifierAndPublicShare &&
          runtimeType == other.runtimeType &&
          identifier == other.identifier &&
          publicShare == other.publicShare;
}

class IdentifierAndSignatureShare {
  final FrostIdentifier identifier;
  final FrostRound2SignatureShare share;

  const IdentifierAndSignatureShare({
    required this.identifier,
    required this.share,
  });

  @override
  int get hashCode => identifier.hashCode ^ share.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is IdentifierAndSignatureShare &&
          runtimeType == other.runtimeType &&
          identifier == other.identifier &&
          share == other.share;
}

class IdentifierAndSigningCommitment {
  final FrostIdentifier identifier;
  final FrostRound1SigningCommitments commitment;

  const IdentifierAndSigningCommitment({
    required this.identifier,
    required this.commitment,
  });

  @override
  int get hashCode => identifier.hashCode ^ commitment.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is IdentifierAndSigningCommitment &&
          runtimeType == other.runtimeType &&
          identifier == other.identifier &&
          commitment == other.commitment;
}

@freezed
sealed class SignAggregationError
    with _$SignAggregationError
    implements FrbException {
  const factory SignAggregationError.general({
    required String message,
  }) = SignAggregationError_General;
  const factory SignAggregationError.invalidSignShare({
    required FrostIdentifier culprit,
  }) = SignAggregationError_InvalidSignShare;
}
